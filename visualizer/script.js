/**
 * Script for the visualizer webpage.
 * Author: Sibert Aerts
 */


//----------------//
// Document.ready //
//----------------//

$(document).ready(function(){
    // Register the file-loading event
    visualizer = new Visualizer('.file-input', '.day-control', '#view');

    // Set panels as draggable
    refreshDraggable();

    // Make panels collapsible
    refreshCollapsable();
})


//--------------------//
// File reading stuff //
//--------------------//

/// Method called on town/city names to turn them nicer.
function nameFormat(name){
    var num = parseInt(name.slice(4));
    if(name.slice(0,4) == "town" && !isNaN(num))
        return "Town " + num;
    else
        // Apply title case
        return name.replace(/\w\S*/g, t => t.charAt(0).toUpperCase() + t.substr(1).toLowerCase());
}

/// Cleans up the JSON that boost generated by parsing strings back to numerics where needed.
/// Also converts the day-by-day infected difference into per day infected count.
function cleanData(data){
    // replace the dict with an array
    var townArray = [];
    for(var i = 0; i < Object.keys(data.towns).length; i++){
        var town = data.towns[""+ i];
        town.name = nameFormat(town.name);
        town.size = parseInt(town.size);
        town.lat = parseFloat(town.lat);
        town.long = parseFloat(town.long);
        townArray.push(town);
    }
    data.towns = townArray;

    for(var i in data.days){
        currentDay = data.days[i];
        if (typeof currentDay != "object")
            currentDay = data.days[i] = {};
        if (i == 0) {
            for(var id in data.towns)
                currentDay[id] = (parseInt(currentDay[id]) || 0);
        } else {
            prevDay = data.days[i - 1];
            for(var id in data.towns){
                currentDay[id] = (parseInt(currentDay[id]) || 0) + (prevDay[id] || 0);
            }
        }
    }
}


//-------------------//
// Class: Visualizer //
//-------------------//

/// Make a new Visualizer bound to the given elements.
var Visualizer = function(inputSelector, controlSelector, viewSelector){
    // Place our hook into the file selector
    $(inputSelector).on('change', (f => this.readFile(f.target.files[0], this.initializeFromFile.bind(this))).bind(this));

    // Place our hooks into the controls
    this.initializeControls(controlSelector);

    // Remember our view
    this.$view = $(viewSelector);

    // Remember that there aren't any panels yet.
    this.townPanels = [];
}

/// Actually initialize the Visualizer with the data retrieved from the file.
Visualizer.prototype.initialize = function(data){
    // Grab the data parsed from the file and aggregate it
    this.days = data.days;
    this.towns = data.towns;
    this.aggregateData();

    // Debug
    // this.addAlignmentTestNodes();

    // Put the total number of days
    this.maxDays = this.days.length;
    $('.days').text(this.maxDays);
    
    // set up the view
    this.makeView();
    this.updateDay(0);

    // enable the controls
    this.configureControls();
}

/// Handler passed to the file selector, called when a file is selected.
/// The argument 'handler' is called when the file is read.
Visualizer.prototype.readFile = function(f, handler){
    if (!f) return;
    this.file = f;
    $(".filename-output").text(this.file.name);
    var reader = new FileReader();
    reader.onload = handler;
    reader.readAsText(this.file);
}

/// Handler passed to readSingleFile.
/// Uses the given file to initialize the visualizer completely.
Visualizer.prototype.initializeFromFile = function(e) {
    clearInterval(this.fileUpdateInterval);
    var data = JSON.parse(e.target.result);
    cleanData(data);

    this.fileLastModifiedTime = this.file.lastModifiedDate.getTime();
    this.fileUpdateInterval = setInterval(this.checkFileUpdated.bind(this), 100);

    this.initialize(data);
}

/// Handler passed to readSingleFile.
/// Gets new day data from the file and updates the visualizer where necessary.
Visualizer.prototype.updateFromFile = function(e) {
    var data = JSON.parse(e.target.result);
    cleanData(data);

    this.fileLastModifiedTime = this.file.lastModifiedDate.getTime();

    // Grab the data parsed from the file and aggregate it
    console.log("Adding " + (data.days.length - this.days.length) + " new days from file.");
    this.days = data.days;
    this.aggregateData();

    // Put the total number of days
    this.maxDays = this.days.length;
    $('.days').text(this.maxDays);
    
    // update the views where necessary:
    // table: nothing

    // graph: remake it entirely
    this.makeGraph();

    // map: Rescale the colour gradient to match the possibly updated maxSingle
    this.countGradient = this.percentGradient.scale(this.maxSingle);
    this.updateLegend();

    // panels: remake each of their graphs entirely
    for (var i in this.townPanels)
        this.townPanels[i].makeGraph();

    // Update the slider's range
    this.control.$range.prop("max", this.maxDays);

    // Update to the already selected day!
    this.updateDay(this.day);
}

/// Method called at an interval, tests whether or not the source file has been modified.
/// If it has been modified, it will read the new data and refresh the visualizer to match.
Visualizer.prototype.checkFileUpdated = function() {
    if (this.fileLastModifiedTime > this.file.lastModifiedDate.getTime()){
        console.log("File updated at " + this.file.lastModifiedDate + ", updating views.");

        // Make sure updateFromFile isn't called multiple times.
        clearInterval(this.fileUpdateInterval);
        this.readFile(this.file, this.updateFromFile.bind(this));
        this.fileUpdateInterval = setInterval(this.checkFileUpdated.bind(this), 100);
    }
}

/// Extract useful information from our data.
Visualizer.prototype.aggregateData = function(){
    // Aggregate from towns
    var maxTownSize = 0;
    var totalSize = 0;
    for(var t in this.towns){
        var size = this.towns[t].size
        maxTownSize = Math.max(maxTownSize, size);
        totalSize += size;
        var max = {day: 0, infected: 0};
        for(var d in this.days){
            if( this.days[d][t] > max.infected){
                max.day = d;
                max.infected = this.days[d][t];
            }
        }
        this.towns[t].max = max;
    }
    this.maxTownSize = maxTownSize;
    this.totalSize = totalSize;
    $(".total-people").text(totalSize);
    $(".total-towns").text(this.towns.length);

    // Aggregate from days
    var maxTotal = 0;
    var maxTotalDay = 0;
    var maxSingle = 0;
    for(var d in this.days){
        var total = 0;
        var maxLocalSingle = 0;
        var maxLocalSingleTown = 0;
        for(var t in this.towns){
            var single = this.days[d][t];
            if(single == undefined)
                continue;
            total += single;
            maxSingle = Math.max(maxSingle, single);
            if(single > maxLocalSingle){
                maxLocalSingle = single;
                maxLocalSingleTown = t;
            }
        }
        this.days[d].total = total;
        this.days[d].max = {infected: maxLocalSingle, town: maxLocalSingleTown};
        if(total > maxTotal){
            maxTotal = total
            maxTotalDay = d;
        }
    }
    this.maxTotal = maxTotal;
    $(".most-total-infected").text(maxTotal);
    $(".most-total-infected-day").text(maxTotalDay);
    $(".most-total-infected-day").unbind("click").on("click",()=>this.updateDay(maxTotalDay));
    this.maxSingle = maxSingle;
}

/// Bind into the controls and set the appropriate events.
Visualizer.prototype.initializeControls = function (controlSelector){
    $c = $(controlSelector);
    var c = this.control = Object();

    // Find the input elements.
    c.$prevDay = $c.find('.prev-day');
    c.$nextDay = $c.find('.next-day');
    c.$range = $c.find('.range-input');
    c.$run = $c.find('.run-input');
    c.$loop = $c.find('.loop-input');
    c.$gradient = $('.gradient-input');
    c.$colourMode = $('.colour-mode-input');

    // Used for enabling-disabling all at once
    c.all = [c.$prevDay, c.$nextDay, c.$range, c.$run, c.$loop, c.$gradient.find("button"), c.$colourMode.find("button")];

    // Bind events
    c.$prevDay.on("click", this.prevDay.bind(this));
    c.$nextDay.on("click", this.nextDay.bind(this));
    c.$range.on("input", () => this.updateDay(parseInt(c.$range.val())));
    c.$run.on("change", () => {if(c.$run.prop("checked")) this.run()});

    // Disable the controls, they're not ready yet.
    this.disableControls();
}

/// Automatically step through the different days of the simulation.
Visualizer.prototype.run = async function(){
    this.runSpeed = 60;
    var $run = this.control.$run;
    var $loop = this.control.$loop;

    while($run.prop("checked")){
        var nextDay = this.day + 1;
        if( nextDay >= this.maxDays ){
            if($loop.prop("checked")){
                nextDay = 0;
            } else {
                $run.prop("checked", false);
                break;
            }
        }
        this.updateDay(nextDay);
        await sleep(this.runSpeed);
    }
}

/// Set up and enable the controls based on the simulation data.
Visualizer.prototype.configureControls = function(){
    // Set the slider range
    this.control.$range.prop("max", this.maxDays);

    // Set the different options in the gradient selector
    var $target = this.control.$gradient.find(".dropdown-menu");
    $target.html("");

    // let because we're trying to bind gradient to a lambda later
    for(let gradient in Gradient.gradients){
        var $a = $("<a>");
        $a.text(gradient);

        $a.on("click", () => this.selectGradient(gradient))

        var $li = $("<li>");
        $li.append($a);
        $target.append($li);
    }

    // Enable the controls
    this.disableControls(false);
}

/// Control interface methods:
Visualizer.prototype.prevDay = function(){ this.updateDay(visualizer.day - 1); }
Visualizer.prototype.nextDay = function(){ this.updateDay(visualizer.day + 1); }

/// Enable or disable the controls.
Visualizer.prototype.disableControls = function(val=true){
    for(i in this.control.all)
        this.control.all[i].prop("disabled", val);
}

/// Add a few easily recognisible items to the map for testing alignment of coordinates to the map.
Visualizer.prototype.addAlignmentTestNodes = function(){
    this.towns.push({name:"Tip of tasmania", size:10,lat:-43.597190, long:146.773835});
    this.towns.push({name:"Tip of South America", size:10,lat:-54.671467,long:-65.129066});
    this.towns.push({name:"Tip of Greenland", size:10,lat:59.831982,long:-43.585772});
    this.towns.push({name:"Tip of India", size:10,lat:8.077824, long:77.551041});
}

/// Add a new panel for the specified town.
/// If such a panel already exists, pop it to the front of the panels.
Visualizer.prototype.makeTownPanel = function(townId){
    var panel = this.townPanels.filter(t=>t.id == townId);
    if(panel.length != 0){
        panel[0].toTop();
        return;
    }
    panel = new TownPanel(this, townId);
    this.townPanels.push(panel);
    this.updateTable();
}

/// Remove all town panels, called when a new input file is loaded.
Visualizer.prototype.removeTownPanels = function(){
    for(var i in this.townPanels){
        this.townPanels[i].remove();
    }
    this.townPanels = [];
}

/// Prepare the HTML document with the basic frameworks for our view.
Visualizer.prototype.makeView = function(){
    this.removeTownPanels();
    this.makeTable();
    this.makeMap();
    this.makeGraph();
}

/// Prepare the HTML document with a basic table.
Visualizer.prototype.makeTable = function(){
    // Find and clear the view target
    $target = this.$view.find(".table-view");
    $target.html("");

    // Make a table
    this.$table = $table = $("<table>", {class:"table table-striped table-condensed"});
    $target.append($table);

    // Header
    $row = $("<tr>");
    $row.append($("<th>Name</th>"));
    $row.append($("<th>Inhabitants</th>"));
    $row.append($("<th>Current infected</th>"));
    $row.append($("<th>Most infected</th>"));
    $table.append($row);

    // Rows
    for(let i in this.towns){
        var town = this.towns[i];
        $row = $("<tr>",{town:noSpace(town.name)});
        $row.append($("<td>").append($("<a>",{class:"clickable",onclick:`visualizer.makeTownPanel(${i})`}).text(town.name)));
        $row.append($("<td>").text(town.size));
        $current = $("<td>");
        $current.append($("<span>", {class:"infected"}));
        $current.append(" : ");
        $current.append($("<span>", {class:"percent"}));
        $row.append($current);
        $max = $("<td>");
        $max.append(`${town.max.infected} on day `);
        $max.append($("<a>",{class:"clickable",onclick:`visualizer.updateDay(${town.max.day})`}).text(town.max.day));
        $row.append($max);
        $table.append($row);
    }
}

/// Add a graph view to the page, doesn't need to be updated! 
Visualizer.prototype.makeGraph = function(){
    $target = $(".graph-view");
    $target.svg("destroy");
    $target.html("");
    $target.svg({settings: {width: "300px", height:"180px"}});
    var $svg = $target.svg("get");

    var percentList = [];
    for(var i in this.days)
        percentList.push(this.days[i].total * 100 / this.totalSize);

    var percentLabels = [];
    for(var i=0;i<=100;i+=10) percentLabels.push(i + "%");

    $svg.graph.noDraw();

    $svg.graph.addSeries("Infected", percentList, "#186", "#2b8", 1);
    $svg.graph.options({barGap:0});
    $svg.graph.legend.show(false);
    $svg.graph.area(0.13, 0.1, 0.98, 0.85);
    $svg.graph.gridlines({stroke: '#aaf', strokeDashArray: '2,4'});
    $svg.graph.yAxis.ticks(10, 5, 8).labels(percentLabels).scale(0, clamp(this.maxTotal / this.totalSize * 120, 10, 100));
    $svg.graph.xAxis.ticks(50, 30, 1).labels("", "transparent");

    $svg.graph.redraw();

    // Day indicator
    var $wrap = $("<div>",{class:"indicator-wrapper"});
    var $indicator = $("<div>",{class:"indicator"});
    $wrap.append($indicator);
    $target.append($wrap);

    this.updateGraph();
}

/// Choose how the circles are coloured.
/// Options: "count" or "percent"
Visualizer.prototype.setGradientMode = function(mode){
    this.colourMode = mode;
    this.updateLegend();
    this.updateMap();
}

/// Select the gradient by the given name.
Visualizer.prototype.selectGradient = function(name){
    this.percentGradient = Gradient.gradients[name];
    this.countGradient = this.percentGradient.scale(this.maxSingle);
    this.updateLegend();
    this.updateMap();
}

/// Initialize the gradient that governs map colouring.
Visualizer.prototype.initializeLegend = function(){
    this.colourMode = "count";
    this.percentGradient = Gradient.gradients["Ultra heat map"];
    this.countGradient = this.percentGradient.scale(this.maxSingle);
    this.$legend = $(".legend-view");
    this.updateLegend();
}

// Updates the legend to match the contents of the selected colour gradient.
Visualizer.prototype.updateLegend = function(){
    this.$legend.html("");
    for(i in this.countGradient.colourMap){
        $item = $("<div>", {class: "legend-item"});

        var colour;
        if(this.colourMode == "count"){
            $item.text(Math.round(this.countGradient.colourMap[i].val));
            colour = this.countGradient.colourMap[i].colour.toString();
        }
        else if(this.colourMode == "percent"){
            $item.text(percentFormat(this.percentGradient.colourMap[i].val, 0));
            colour = this.percentGradient.colourMap[i].colour.toString();
        }

        $item.append($("<span>", {class:"legend-circle",style:"background-color:"+colour}));

        this.$legend.append($item);
    }
}

// Find the box of latitudes/longitudes containing all known locations.
// Returns an object {minLat, maxLat, minLong, maxLong}
Visualizer.prototype.findBox = function(){
    var out = {minLat: 1000, maxLat: -1000, minLong: 1000, maxLong: -1000};

    for(town in this.towns){
        out.minLat = Math.min(this.towns[town].lat, out.minLat);
        out.maxLat = Math.max(this.towns[town].lat, out.maxLat);
        out.minLong = Math.min(this.towns[town].long, out.minLong);
        out.maxLong = Math.max(this.towns[town].long, out.maxLong);
    }

    return out;
}

/// Prepare the HTML document with a basic table.
Visualizer.prototype.makeMap = function(){
    // Find and clear the view target
    var $target = this.$view.find(".map-view");
    $target.svg("destroy");
    $target.html("");

    this.initializeLegend();

    var box = this.findBox();
    var width = 1100;
    var height = 800;

    this.infectedSizeFunc = val => Math.sqrt(val) * 8/Math.sqrt(this.maxSingle) + 2;
    this.townSizeFunc = val => Math.pow(val, 0.3) * 10/Math.pow(this.maxTownSize, 0.3) + 2;

    // Check if any of the data fits inside a known map.
    for(i in Map.maps){
        map = Map.maps[i];
        if(map.containsBox(box)){
            console.log("Found map: " + map.name);
            // Crop the map
            var o = map.getCrop(width, height, box);
            $crop = $("<div>",{class:"map-image-crop", width:width, height:height});
            $img = $("<img>",{src:map.imageRef, width:o.width, height:o.height});
            $img.css({position: "absolute", top: -o.top, left: -o.left});
            $crop.append($img);
            $target.append($crop);
            box = o.box;
            break;
        }
    }

    // Functions converting lat/longitudes into percentages.
    var latFunc = lat => (lat - box.minLat) / (box.maxLat - box.minLat);
    var longFunc = long => (long - box.minLong) / (box.maxLong - box.minLong);

    // Make an SVG element
    $target.svg({settings: {width:width,height:height}});
    var svgMap = $target.svg("get");

    // Fill it with circles
    for(let i in this.towns){
        let town = this.towns[i];
        // Determine its features
        var x = percentFormat(longFunc(town.long));
        var y = percentFormat(1- latFunc(town.lat));
        var radius = 5;

        // Make and attach the circle
        var dot = svgMap.circle(x, y, radius);

        // Remember the circle for later
        town.dot = dot;

        // Add a little tooltip
        dot.setAttribute("title", town.name);
        dot.setAttribute("data-toggle", "tooltip");
        dot.setAttribute("data-container", "body");
        dot.setAttribute("r", this.townSizeFunc(town.size));
        dot.onclick = ()=>this.makeTownPanel(i);
    }
    refreshTooltips();
}

/// Update the view to match the info at that day.
Visualizer.prototype.updateDay = function(day){
    // clamp day to the valid range
    day = parseInt(day);
    day = clamp(day, 0, this.maxDays-1);

    this.day = day;
    $('.current-day').text(1 + day);
    this.control.$range.prop("value", day);
    $('.total-infected').text(this.days[day].total);
    $('.percentage-infected').text(percentFormat(this.days[day].total/this.totalSize));
    $('.most-current-infected').text(this.days[day].max.infected);
    $('.most-current-infected-town').text(this.towns[this.days[day].max.town].name);
    $('.most-current-infected-town').unbind("click");
    $('.most-current-infected-town').on("click", ()=>this.makeTownPanel(this.days[day].max.town));

    this.updateView();
}

/// Update the view to reflect the currently selected day.
Visualizer.prototype.updateView = function(){
    this.updateTable();
    this.updateMap();
    this.updateGraph();
}

/// Update the table to reflect the currently selected day.
Visualizer.prototype.updateTable = function(){
    var currentDay = this.days[this.day];

    // Update each column
    for(var town in this.towns){
        var count = currentDay[town] || 0;

        // Find the table column for the given town
        var $col = $("[town=" + noSpace(this.towns[town].name + "]"));

        // Put the amount of infected
        $col.find(".infected").text(count);

        // Write the percentage infected if any
        var percent = count/this.towns[town].size;
        $col.find(".percent").text(percentFormat(percent));
    }
}

/// Update the map to reflect the currently selected day.
Visualizer.prototype.updateMap = function(){
    var currentDay = this.days[this.day];

    for(var town in this.towns){
        var val = currentDay[town] || 0;
        var size = this.towns[town].size;
        var dot = this.towns[town].dot;

        if(this.colourMode == "count")
            dot.setAttribute("fill", this.countGradient.get(val).toString());
        else if(this.colourMode == "percent")
            dot.setAttribute("fill", this.percentGradient.get(val/size).toString());

        // dot.setAttribute("r", this.sizeFunc(val));
    }
}

/// Update all graphs to reflect the currently selected day.
Visualizer.prototype.updateGraph = function(){
    $('.indicator-wrapper > .indicator').css({left: percentFormat(this.day/this.maxDays, 4)});
}